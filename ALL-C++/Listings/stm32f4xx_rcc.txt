; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f4xx_rcc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_rcc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I.\USER -I.\SCR -I.\Libraries\CMSIS\Include -I.\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I.\Libraries\STM32F4xx_StdPeriph_Driver\inc -D__UVISION_VERSION=535 -DSTM32F446xx -DUSE_STDPERIPH_DRIVER -DSTM32F446xx -DHSE_VALUE=8000000 --omf_browse=.\objects\stm32f4xx_rcc.crf Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_48MHzClockSourceConfig||, CODE, READONLY, ALIGN=2

                  RCC_48MHzClockSourceConfig PROC
;;;2793     */
;;;2794   void RCC_48MHzClockSourceConfig(uint8_t RCC_ClockSource)
000000  2801              CMP      r0,#1
;;;2795   {
;;;2796     /* Check the parameters */
;;;2797     assert_param(IS_RCC_48MHZ_CLOCKSOURCE(RCC_ClockSource));
;;;2798   #if defined(STM32F469_479xx) 
;;;2799     if(RCC_ClockSource == RCC_48MHZCLKSource_PLLSAI)
;;;2800     {
;;;2801       SET_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CK48MSEL);
;;;2802     }
;;;2803     else
;;;2804     {
;;;2805       CLEAR_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CK48MSEL);
;;;2806     }
;;;2807   #elif  defined(STM32F446xx)
;;;2808     if(RCC_ClockSource == RCC_48MHZCLKSource_PLLSAI)
000002  d106              BNE      |L1.18|
;;;2809     {
;;;2810       SET_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL);
000004  4906              LDR      r1,|L1.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0416100          ORR      r1,r1,#0x8000000
00000c  4a04              LDR      r2,|L1.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L1.30|
                  |L1.18|
;;;2811     }
;;;2812     else
;;;2813     {
;;;2814       CLEAR_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL);
000012  4903              LDR      r1,|L1.32|
000014  6809              LDR      r1,[r1,#0]
000016  f0216100          BIC      r1,r1,#0x8000000
00001a  4a01              LDR      r2,|L1.32|
00001c  6011              STR      r1,[r2,#0]
                  |L1.30|
;;;2815     }
;;;2816   #elif defined(STM32F412xG) || defined(STM32F413_423xx)
;;;2817     if(RCC_ClockSource == RCC_CK48CLKSOURCE_PLLI2SQ)
;;;2818     {
;;;2819       SET_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL);
;;;2820     }
;;;2821     else
;;;2822     {
;;;2823       CLEAR_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL);
;;;2824     }
;;;2825   #else
;;;2826   #endif /* STM32F469_479xx */  
;;;2827   }
00001e  4770              BX       lr
;;;2828   
                          ENDP

                  |L1.32|
                          DCD      0x40023894

                          AREA ||i.RCC_AHB1ClockGatingCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1ClockGatingCmd PROC
;;;2881     */
;;;2882   void RCC_AHB1ClockGatingCmd(uint32_t RCC_AHB1ClockGating, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;2883   {
;;;2884     /* Check the parameters */
;;;2885     assert_param(IS_RCC_AHB1_CLOCKGATING(RCC_AHB1ClockGating));
;;;2886   
;;;2887     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2888     if (NewState != DISABLE)
;;;2889     {
;;;2890       RCC->CKGATENR &= ~RCC_AHB1ClockGating;
000002  4a06              LDR      r2,|L2.28|
000004  6812              LDR      r2,[r2,#0]
000006  4382              BICS     r2,r2,r0
000008  4b04              LDR      r3,|L2.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L2.24|
                  |L2.14|
;;;2891     }
;;;2892     else
;;;2893     {
;;;2894       RCC->CKGATENR |= RCC_AHB1ClockGating;
00000e  4a03              LDR      r2,|L2.28|
000010  6812              LDR      r2,[r2,#0]
000012  4302              ORRS     r2,r2,r0
000014  4b01              LDR      r3,|L2.28|
000016  601a              STR      r2,[r3,#0]
                  |L2.24|
;;;2895     }
;;;2896   }
000018  4770              BX       lr
;;;2897   
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40023890

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;2103     */
;;;2104   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;2105   {
;;;2106     /* Check the parameters */
;;;2107     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;2108   
;;;2109     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2110     if (NewState != DISABLE)
;;;2111     {
;;;2112       RCC->AHB1ENR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L3.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L3.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;2113     }
;;;2114     else
;;;2115     {
;;;2116       RCC->AHB1ENR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L3.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L3.28|
000016  601a              STR      r2,[r3,#0]
                  |L3.24|
;;;2117     }
;;;2118   }
000018  4770              BX       lr
;;;2119   
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;2522     */
;;;2523   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;2524   {
;;;2525     /* Check the parameters */
;;;2526     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;2527     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2528     if (NewState != DISABLE)
;;;2529     {
;;;2530       RCC->AHB1LPENR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L4.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;2531     }
;;;2532     else
;;;2533     {
;;;2534       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L4.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  601a              STR      r2,[r3,#0]
                  |L4.24|
;;;2535     }
;;;2536   }
000018  4770              BX       lr
;;;2537   
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;2316     */
;;;2317   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L5.14|
;;;2318   {
;;;2319     /* Check the parameters */
;;;2320     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;2321     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2322   
;;;2323     if (NewState != DISABLE)
;;;2324     {
;;;2325       RCC->AHB1RSTR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L5.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L5.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;2326     }
;;;2327     else
;;;2328     {
;;;2329       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L5.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L5.28|
000016  601a              STR      r2,[r3,#0]
                  |L5.24|
;;;2330     }
;;;2331   }
000018  4770              BX       lr
;;;2332   
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;2135     */
;;;2136   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L6.14|
;;;2137   {
;;;2138     /* Check the parameters */
;;;2139     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;2140     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2141   
;;;2142     if (NewState != DISABLE)
;;;2143     {
;;;2144       RCC->AHB2ENR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L6.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L6.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;2145     }
;;;2146     else
;;;2147     {
;;;2148       RCC->AHB2ENR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L6.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L6.28|
000016  601a              STR      r2,[r3,#0]
                  |L6.24|
;;;2149     }
;;;2150   }
000018  4770              BX       lr
;;;2151   
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;2554     */
;;;2555   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L7.14|
;;;2556   {
;;;2557     /* Check the parameters */
;;;2558     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;2559     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2560     if (NewState != DISABLE)
;;;2561     {
;;;2562       RCC->AHB2LPENR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L7.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L7.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L7.24|
                  |L7.14|
;;;2563     }
;;;2564     else
;;;2565     {
;;;2566       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L7.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L7.28|
000016  601a              STR      r2,[r3,#0]
                  |L7.24|
;;;2567     }
;;;2568   }
000018  4770              BX       lr
;;;2569   
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;2345     */
;;;2346   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L8.14|
;;;2347   {
;;;2348     /* Check the parameters */
;;;2349     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;2350     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2351   
;;;2352     if (NewState != DISABLE)
;;;2353     {
;;;2354       RCC->AHB2RSTR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L8.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L8.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;2355     }
;;;2356     else
;;;2357     {
;;;2358       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L8.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L8.28|
000016  601a              STR      r2,[r3,#0]
                  |L8.24|
;;;2359     }
;;;2360   }
000018  4770              BX       lr
;;;2361   
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;2165     */
;;;2166   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L9.14|
;;;2167   {
;;;2168     /* Check the parameters */
;;;2169     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;2170     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2171   
;;;2172     if (NewState != DISABLE)
;;;2173     {
;;;2174       RCC->AHB3ENR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L9.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L9.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L9.24|
                  |L9.14|
;;;2175     }
;;;2176     else
;;;2177     {
;;;2178       RCC->AHB3ENR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L9.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L9.28|
000016  601a              STR      r2,[r3,#0]
                  |L9.24|
;;;2179     }
;;;2180   }
000018  4770              BX       lr
;;;2181   #endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx || STM32F427_437xx || STM32F429_439xx || STM32F446xx || STM32F469_479xx */
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;2584     */
;;;2585   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;2586   {
;;;2587     /* Check the parameters */
;;;2588     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;2589     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2590     if (NewState != DISABLE)
;;;2591     {
;;;2592       RCC->AHB3LPENR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L10.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L10.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L10.24|
                  |L10.14|
;;;2593     }
;;;2594     else
;;;2595     {
;;;2596       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L10.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L10.28|
000016  601a              STR      r2,[r3,#0]
                  |L10.24|
;;;2597     }
;;;2598   }
000018  4770              BX       lr
;;;2599   #endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx || STM32F427_437xx || STM32F429_439xx || STM32F446xx || STM32F469_479xx */
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;2372     */
;;;2373   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L11.14|
;;;2374   {
;;;2375     /* Check the parameters */
;;;2376     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;2377     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2378   
;;;2379     if (NewState != DISABLE)
;;;2380     {
;;;2381       RCC->AHB3RSTR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L11.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L11.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L11.24|
                  |L11.14|
;;;2382     }
;;;2383     else
;;;2384     {
;;;2385       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L11.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L11.28|
000016  601a              STR      r2,[r3,#0]
                  |L11.24|
;;;2386     }
;;;2387   }
000018  4770              BX       lr
;;;2388   #endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx || STM32F427_437xx || STM32F429_439xx || STM32F446xx || STM32F469_479xx */
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;2222     */
;;;2223   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L12.14|
;;;2224   {
;;;2225     /* Check the parameters */
;;;2226     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;2227     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2228   
;;;2229     if (NewState != DISABLE)
;;;2230     {
;;;2231       RCC->APB1ENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L12.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L12.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;2232     }
;;;2233     else
;;;2234     {
;;;2235       RCC->APB1ENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L12.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L12.28|
000016  601a              STR      r2,[r3,#0]
                  |L12.24|
;;;2236     }
;;;2237   }
000018  4770              BX       lr
;;;2238   
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;2641     */
;;;2642   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L13.14|
;;;2643   {
;;;2644     /* Check the parameters */
;;;2645     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;2646     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2647     if (NewState != DISABLE)
;;;2648     {
;;;2649       RCC->APB1LPENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L13.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L13.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L13.24|
                  |L13.14|
;;;2650     }
;;;2651     else
;;;2652     {
;;;2653       RCC->APB1LPENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L13.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L13.28|
000016  601a              STR      r2,[r3,#0]
                  |L13.24|
;;;2654     }
;;;2655   }
000018  4770              BX       lr
;;;2656   
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;2426     */
;;;2427   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L14.14|
;;;2428   {
;;;2429     /* Check the parameters */
;;;2430     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;2431     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2432     if (NewState != DISABLE)
;;;2433     {
;;;2434       RCC->APB1RSTR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L14.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L14.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L14.24|
                  |L14.14|
;;;2435     }
;;;2436     else
;;;2437     {
;;;2438       RCC->APB1RSTR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L14.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L14.28|
000016  601a              STR      r2,[r3,#0]
                  |L14.24|
;;;2439     }
;;;2440   }
000018  4770              BX       lr
;;;2441   
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;2274     */
;;;2275   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L15.14|
;;;2276   {
;;;2277     /* Check the parameters */
;;;2278     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;2279     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2280   
;;;2281     if (NewState != DISABLE)
;;;2282     {
;;;2283       RCC->APB2ENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L15.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L15.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L15.24|
                  |L15.14|
;;;2284     }
;;;2285     else
;;;2286     {
;;;2287       RCC->APB2ENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L15.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L15.28|
000016  601a              STR      r2,[r3,#0]
                  |L15.24|
;;;2288     }
;;;2289   }
000018  4770              BX       lr
;;;2290   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;2693     */
;;;2694   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L16.14|
;;;2695   {
;;;2696     /* Check the parameters */
;;;2697     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;2698     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2699     if (NewState != DISABLE)
;;;2700     {
;;;2701       RCC->APB2LPENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L16.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L16.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L16.24|
                  |L16.14|
;;;2702     }
;;;2703     else
;;;2704     {
;;;2705       RCC->APB2LPENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L16.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L16.28|
000016  601a              STR      r2,[r3,#0]
                  |L16.24|
;;;2706     }
;;;2707   }
000018  4770              BX       lr
;;;2708   
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;2473     */
;;;2474   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L17.14|
;;;2475   {
;;;2476     /* Check the parameters */
;;;2477     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;2478     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2479     if (NewState != DISABLE)
;;;2480     {
;;;2481       RCC->APB2RSTR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L17.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L17.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L17.24|
                  |L17.14|
;;;2482     }
;;;2483     else
;;;2484     {
;;;2485       RCC->APB2RSTR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L17.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L17.28|
000016  601a              STR      r2,[r3,#0]
                  |L17.24|
;;;2486     }
;;;2487   }
000018  4770              BX       lr
;;;2488   
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;338      */
;;;339    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4601              MOV      r1,r0
;;;340    {
;;;341      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;342      /* Check the parameters */
;;;343      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;344    
;;;345      tmpreg = RCC->CR;
000004  4a03              LDR      r2,|L18.20|
000006  6810              LDR      r0,[r2,#0]
;;;346    
;;;347      /* Clear HSITRIM[4:0] bits */
;;;348      tmpreg &= ~RCC_CR_HSITRIM;
000008  f02000f8          BIC      r0,r0,#0xf8
;;;349    
;;;350      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;351      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;352    
;;;353      /* Store the new value */
;;;354      RCC->CR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;355    }
000012  4770              BX       lr
;;;356    
                          ENDP

                  |L18.20|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1518     */
;;;1519   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;1520   {
;;;1521     /* Check the parameters */
;;;1522     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1523     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1524   }
000004  4770              BX       lr
;;;1525   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_CECClockSourceConfig||, CODE, READONLY, ALIGN=2

                  RCC_CECClockSourceConfig PROC
;;;2930     */
;;;2931   void RCC_CECClockSourceConfig(uint8_t RCC_ClockSource)
000000  2801              CMP      r0,#1
;;;2932   {
;;;2933     /* Check the parameters */
;;;2934     assert_param(IS_RCC_CEC_CLOCKSOURCE(RCC_ClockSource));
;;;2935     
;;;2936     if(RCC_ClockSource == RCC_CECCLKSource_LSE)
000002  d106              BNE      |L20.18|
;;;2937     {
;;;2938       SET_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL);
000004  4906              LDR      r1,|L20.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0416180          ORR      r1,r1,#0x4000000
00000c  4a04              LDR      r2,|L20.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L20.30|
                  |L20.18|
;;;2939     }
;;;2940     else
;;;2941     {
;;;2942       CLEAR_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL);
000012  4903              LDR      r1,|L20.32|
000014  6809              LDR      r1,[r1,#0]
000016  f0216180          BIC      r1,r1,#0x4000000
00001a  4a01              LDR      r2,|L20.32|
00001c  6011              STR      r1,[r2,#0]
                  |L20.30|
;;;2943     }
;;;2944   }
00001e  4770              BX       lr
;;;2945   #endif /* STM32F446xx */
                          ENDP

                  |L20.32|
                          DCD      0x40023894

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;3111     */
;;;3112   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L21.16|
;;;3113   {
;;;3114     /* Set RMVF bit to clear the reset flags */
;;;3115     RCC->CSR |= RCC_CSR_RMVF;
000002  6800              LDR      r0,[r0,#0]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L21.16|
00000a  6008              STR      r0,[r1,#0]
;;;3116   }
00000c  4770              BX       lr
;;;3117   
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;3165     */
;;;3166   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L22.8|
;;;3167   {
;;;3168     /* Check the parameters */
;;;3169     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;3170   
;;;3171     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;3172        pending bits */
;;;3173     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;3174   }
000004  4770              BX       lr
;;;3175   
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;878      */
;;;879    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L23.8|
;;;880    {
;;;881      /* Check the parameters */
;;;882      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;883      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;884    }
000004  4770              BX       lr
;;;885    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;224      */
;;;225    void RCC_DeInit(void)
000000  4814              LDR      r0,|L24.84|
;;;226    {
;;;227      /* Set HSION bit */
;;;228      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4912              LDR      r1,|L24.84|
00000a  6008              STR      r0,[r1,#0]
;;;229    
;;;230      /* Reset CFGR register */
;;;231      RCC->CFGR = 0x00000000;
00000c  2000              MOVS     r0,#0
00000e  4911              LDR      r1,|L24.84|
000010  3108              ADDS     r1,r1,#8
000012  6008              STR      r0,[r1,#0]
;;;232    
;;;233      /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42xxx/43xxx/446xx/469xx/479xx devices) bits */
;;;234      RCC->CR &= (uint32_t)0xEAF6FFFF;
000014  480f              LDR      r0,|L24.84|
000016  6800              LDR      r0,[r0,#0]
000018  490f              LDR      r1,|L24.88|
00001a  4008              ANDS     r0,r0,r1
00001c  490d              LDR      r1,|L24.84|
00001e  6008              STR      r0,[r1,#0]
;;;235      
;;;236      /* Reset PLLCFGR register */
;;;237      RCC->PLLCFGR = 0x24003010;
000020  480e              LDR      r0,|L24.92|
000022  1d09              ADDS     r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;238    
;;;239    #if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F413_423xx) || defined(STM32F469_479xx)  
;;;240      /* Reset PLLI2SCFGR register */
;;;241      RCC->PLLI2SCFGR = 0x20003000;
000026  480e              LDR      r0,|L24.96|
000028  490a              LDR      r1,|L24.84|
00002a  3184              ADDS     r1,r1,#0x84
00002c  6008              STR      r0,[r1,#0]
;;;242    #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F446xx || STM32F413_423xx || STM32F469_479xx */
;;;243    
;;;244    #if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx) 
;;;245      /* Reset PLLSAICFGR register, only available for STM32F42xxx/43xxx/446xx/469xx/479xx devices */
;;;246      RCC->PLLSAICFGR = 0x24003000;
00002e  480b              LDR      r0,|L24.92|
000030  3810              SUBS     r0,r0,#0x10
000032  1d09              ADDS     r1,r1,#4
000034  6008              STR      r0,[r1,#0]
;;;247    #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F446xx || STM32F469_479xx */
;;;248      
;;;249      /* Reset HSEBYP bit */
;;;250      RCC->CR &= (uint32_t)0xFFFBFFFF;
000036  4807              LDR      r0,|L24.84|
000038  6800              LDR      r0,[r0,#0]
00003a  f4202080          BIC      r0,r0,#0x40000
00003e  4905              LDR      r1,|L24.84|
000040  6008              STR      r0,[r1,#0]
;;;251    
;;;252      /* Disable all interrupts */
;;;253      RCC->CIR = 0x00000000;
000042  2000              MOVS     r0,#0
000044  4903              LDR      r1,|L24.84|
000046  310c              ADDS     r1,r1,#0xc
000048  6008              STR      r0,[r1,#0]
;;;254    
;;;255      /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx and STM32F413_423xx devices */
;;;256      RCC->DCKCFGR = 0x00000000;
00004a  4902              LDR      r1,|L24.84|
00004c  318c              ADDS     r1,r1,#0x8c
00004e  6008              STR      r0,[r1,#0]
;;;257      
;;;258    #if defined(STM32F410xx) || defined(STM32F413_423xx)
;;;259      /* Disable LPTIM and FMPI2C clock prescalers selection, only available for STM32F410xx and STM32F413_423xx devices */
;;;260      RCC->DCKCFGR2 = 0x00000000;
;;;261    #endif /* STM32F410xx || STM32F413_423xx */  
;;;262    }
000050  4770              BX       lr
;;;263    
                          ENDP

000052  0000              DCW      0x0000
                  |L24.84|
                          DCD      0x40023800
                  |L24.88|
                          DCD      0xeaf6ffff
                  |L24.92|
                          DCD      0x24003010
                  |L24.96|
                          DCD      0x20003000

                          AREA ||i.RCC_FMPI2C1ClockSourceConfig||, CODE, READONLY, ALIGN=2

                  RCC_FMPI2C1ClockSourceConfig PROC
;;;2957     */
;;;2958   void RCC_FMPI2C1ClockSourceConfig(uint32_t RCC_ClockSource)
000000  4905              LDR      r1,|L25.24|
;;;2959   {
;;;2960     /* Check the parameters */
;;;2961     assert_param(IS_RCC_FMPI2C1_CLOCKSOURCE(RCC_ClockSource));
;;;2962   
;;;2963     /* Clear FMPI2C1 clock source selection source bits */
;;;2964     RCC->DCKCFGR2 &= ~RCC_DCKCFGR2_FMPI2C1SEL;
000002  6809              LDR      r1,[r1,#0]
000004  f4210140          BIC      r1,r1,#0xc00000
000008  4a03              LDR      r2,|L25.24|
00000a  6011              STR      r1,[r2,#0]
;;;2965     /* Set new FMPI2C1 clock source */
;;;2966     RCC->DCKCFGR2 |= RCC_ClockSource;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;2967   }
000014  4770              BX       lr
;;;2968   #endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
                          ENDP

000016  0000              DCW      0x0000
                  |L25.24|
                          DCD      0x40023894

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;1316     */
;;;1317   void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1318   {
;;;1319     uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
000004  2100              MOVS     r1,#0
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
00000a  2602              MOVS     r6,#2
00000c  2500              MOVS     r5,#0
00000e  2202              MOVS     r2,#2
;;;1320   #if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)  
;;;1321     uint32_t pllr = 2;
000010  2702              MOVS     r7,#2
;;;1322   #endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
;;;1323     
;;;1324     /* Get SYSCLK source -------------------------------------------------------*/
;;;1325     tmp = RCC->CFGR & RCC_CFGR_SWS;
000012  f8dfc1a4          LDR      r12,|L26.440|
000016  f8dcc000          LDR      r12,[r12,#0]
00001a  f00c010c          AND      r1,r12,#0xc
;;;1326     
;;;1327     switch (tmp)
00001e  b131              CBZ      r1,|L26.46|
000020  2904              CMP      r1,#4
000022  d009              BEQ      |L26.56|
000024  2908              CMP      r1,#8
000026  d00c              BEQ      |L26.66|
000028  290c              CMP      r1,#0xc
00002a  d17c              BNE      |L26.294|
00002c  e048              B        |L26.192|
                  |L26.46|
;;;1328     {
;;;1329     case 0x00:  /* HSI used as system clock source */
;;;1330       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00002e  f8dfc18c          LDR      r12,|L26.444|
000032  f8c0c000          STR      r12,[r0,#0]
;;;1331       break;
000036  e089              B        |L26.332|
                  |L26.56|
;;;1332     case 0x04:  /* HSE used as system clock  source */
;;;1333       RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000038  f8dfc184          LDR      r12,|L26.448|
00003c  f8c0c000          STR      r12,[r0,#0]
;;;1334       break;
000040  e084              B        |L26.332|
                  |L26.66|
;;;1335     case 0x08:  /* PLL P used as system clock  source */
;;;1336       
;;;1337       /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1338       SYSCLK = PLL_VCO / PLLP
;;;1339       */    
;;;1340       pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
000042  f8dfc174          LDR      r12,|L26.440|
000046  f1ac0c04          SUB      r12,r12,#4
00004a  f8dcc000          LDR      r12,[r12,#0]
00004e  f3cc5580          UBFX     r5,r12,#22,#1
;;;1341       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
000052  f8dfc164          LDR      r12,|L26.440|
000056  f1ac0c04          SUB      r12,r12,#4
00005a  f8dcc000          LDR      r12,[r12,#0]
00005e  f00c023f          AND      r2,r12,#0x3f
;;;1342       
;;;1343       if (pllsource != 0)
000062  b175              CBZ      r5,|L26.130|
;;;1344       {
;;;1345         /* HSE used as PLL clock source */
;;;1346         pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000064  f8dfc158          LDR      r12,|L26.448|
000068  fbbcfcf2          UDIV     r12,r12,r2
00006c  f8df8148          LDR      r8,|L26.440|
000070  f1a80804          SUB      r8,r8,#4
000074  f8d88000          LDR      r8,[r8,#0]
000078  f3c81888          UBFX     r8,r8,#6,#9
00007c  fb0cf408          MUL      r4,r12,r8
000080  e00d              B        |L26.158|
                  |L26.130|
;;;1347       }
;;;1348       else
;;;1349       {
;;;1350         /* HSI used as PLL clock source */
;;;1351         pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000082  f8dfc138          LDR      r12,|L26.444|
000086  fbbcfcf2          UDIV     r12,r12,r2
00008a  f8df812c          LDR      r8,|L26.440|
00008e  f1a80804          SUB      r8,r8,#4
000092  f8d88000          LDR      r8,[r8,#0]
000096  f3c81888          UBFX     r8,r8,#6,#9
00009a  fb0cf408          MUL      r4,r12,r8
                  |L26.158|
;;;1352       }
;;;1353       
;;;1354       pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00009e  f8dfc118          LDR      r12,|L26.440|
0000a2  f1ac0c04          SUB      r12,r12,#4
0000a6  f8dcc000          LDR      r12,[r12,#0]
0000aa  f3cc4c01          UBFX     r12,r12,#16,#2
0000ae  f10c0c01          ADD      r12,r12,#1
0000b2  ea4f064c          LSL      r6,r12,#1
;;;1355       RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
0000b6  fbb4fcf6          UDIV     r12,r4,r6
0000ba  f8c0c000          STR      r12,[r0,#0]
;;;1356       break;
0000be  e045              B        |L26.332|
                  |L26.192|
;;;1357   
;;;1358   #if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
;;;1359     case 0x0C:  /* PLL R used as system clock  source */
;;;1360       /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1361       SYSCLK = PLL_VCO / PLLR
;;;1362       */    
;;;1363       pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
0000c0  f8dfc0f4          LDR      r12,|L26.440|
0000c4  f1ac0c04          SUB      r12,r12,#4
0000c8  f8dcc000          LDR      r12,[r12,#0]
0000cc  f3cc5580          UBFX     r5,r12,#22,#1
;;;1364       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
0000d0  f8dfc0e4          LDR      r12,|L26.440|
0000d4  f1ac0c04          SUB      r12,r12,#4
0000d8  f8dcc000          LDR      r12,[r12,#0]
0000dc  f00c023f          AND      r2,r12,#0x3f
;;;1365       
;;;1366       if (pllsource != 0)
0000e0  b175              CBZ      r5,|L26.256|
;;;1367       {
;;;1368         /* HSE used as PLL clock source */
;;;1369         pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
0000e2  f8dfc0dc          LDR      r12,|L26.448|
0000e6  fbbcfcf2          UDIV     r12,r12,r2
0000ea  f8df80cc          LDR      r8,|L26.440|
0000ee  f1a80804          SUB      r8,r8,#4
0000f2  f8d88000          LDR      r8,[r8,#0]
0000f6  f3c81888          UBFX     r8,r8,#6,#9
0000fa  fb0cf408          MUL      r4,r12,r8
0000fe  e00d              B        |L26.284|
                  |L26.256|
;;;1370       }
;;;1371       else
;;;1372       {
;;;1373         /* HSI used as PLL clock source */
;;;1374         pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000100  f8dfc0b8          LDR      r12,|L26.444|
000104  fbbcfcf2          UDIV     r12,r12,r2
000108  f8df80ac          LDR      r8,|L26.440|
00010c  f1a80804          SUB      r8,r8,#4
000110  f8d88000          LDR      r8,[r8,#0]
000114  f3c81888          UBFX     r8,r8,#6,#9
000118  fb0cf408          MUL      r4,r12,r8
                  |L26.284|
;;;1375       }
;;;1376       
;;;1377       pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>28) + 1 ) *2;
00011c  f8dfc098          LDR      r12,|L26.440|
000120  f1ac0c04          SUB      r12,r12,#4
000124  e000              B        |L26.296|
                  |L26.294|
000126  e00c              B        |L26.322|
                  |L26.296|
000128  f8dcc000          LDR      r12,[r12,#0]
00012c  f3cc7c02          UBFX     r12,r12,#28,#3
000130  f10c0c01          ADD      r12,r12,#1
000134  ea4f074c          LSL      r7,r12,#1
;;;1378       RCC_Clocks->SYSCLK_Frequency = pllvco/pllr;    
000138  fbb4fcf7          UDIV     r12,r4,r7
00013c  f8c0c000          STR      r12,[r0,#0]
;;;1379       break;
000140  e004              B        |L26.332|
                  |L26.322|
;;;1380   #endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
;;;1381       
;;;1382     default:
;;;1383       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000142  f8dfc078          LDR      r12,|L26.444|
000146  f8c0c000          STR      r12,[r0,#0]
;;;1384       break;
00014a  bf00              NOP      
                  |L26.332|
00014c  bf00              NOP                            ;1331
;;;1385     }
;;;1386     /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;1387     
;;;1388     /* Get HCLK prescaler */
;;;1389     tmp = RCC->CFGR & RCC_CFGR_HPRE;
00014e  f8dfc068          LDR      r12,|L26.440|
000152  f8dcc000          LDR      r12,[r12,#0]
000156  f00c01f0          AND      r1,r12,#0xf0
;;;1390     tmp = tmp >> 4;
00015a  0909              LSRS     r1,r1,#4
;;;1391     presc = APBAHBPrescTable[tmp];
00015c  f8dfc064          LDR      r12,|L26.452|
000160  f81c3001          LDRB     r3,[r12,r1]
;;;1392     /* HCLK clock frequency */
;;;1393     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
000164  f8d0c000          LDR      r12,[r0,#0]
000168  fa2cfc03          LSR      r12,r12,r3
00016c  f8c0c004          STR      r12,[r0,#4]
;;;1394   
;;;1395     /* Get PCLK1 prescaler */
;;;1396     tmp = RCC->CFGR & RCC_CFGR_PPRE1;
000170  f8dfc044          LDR      r12,|L26.440|
000174  f8dcc000          LDR      r12,[r12,#0]
000178  f40c51e0          AND      r1,r12,#0x1c00
;;;1397     tmp = tmp >> 10;
00017c  0a89              LSRS     r1,r1,#10
;;;1398     presc = APBAHBPrescTable[tmp];
00017e  f8dfc044          LDR      r12,|L26.452|
000182  f81c3001          LDRB     r3,[r12,r1]
;;;1399     /* PCLK1 clock frequency */
;;;1400     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000186  f8d0c004          LDR      r12,[r0,#4]
00018a  fa2cfc03          LSR      r12,r12,r3
00018e  f8c0c008          STR      r12,[r0,#8]
;;;1401   
;;;1402     /* Get PCLK2 prescaler */
;;;1403     tmp = RCC->CFGR & RCC_CFGR_PPRE2;
000192  f8dfc024          LDR      r12,|L26.440|
000196  f8dcc000          LDR      r12,[r12,#0]
00019a  f40c4160          AND      r1,r12,#0xe000
;;;1404     tmp = tmp >> 13;
00019e  0b49              LSRS     r1,r1,#13
;;;1405     presc = APBAHBPrescTable[tmp];
0001a0  f8dfc020          LDR      r12,|L26.452|
0001a4  f81c3001          LDRB     r3,[r12,r1]
;;;1406     /* PCLK2 clock frequency */
;;;1407     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0001a8  f8d0c004          LDR      r12,[r0,#4]
0001ac  fa2cfc03          LSR      r12,r12,r3
0001b0  f8c0c00c          STR      r12,[r0,#0xc]
;;;1408   }
0001b4  e8bd81f0          POP      {r4-r8,pc}
;;;1409   
                          ENDP

                  |L26.440|
                          DCD      0x40023808
                  |L26.444|
                          DCD      0x00f42400
                  |L26.448|
                          DCD      0x007a1200
                  |L26.452|
                          DCD      APBAHBPrescTable

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;3066     */
;;;3067   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;3068   {
000002  4601              MOV      r1,r0
;;;3069     uint32_t tmp = 0;
000004  2200              MOVS     r2,#0
;;;3070     uint32_t statusreg = 0;
000006  2300              MOVS     r3,#0
;;;3071     FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;3072   
;;;3073     /* Check the parameters */
;;;3074     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;3075   
;;;3076     /* Get the RCC register index */
;;;3077     tmp = RCC_FLAG >> 5;
00000a  114a              ASRS     r2,r1,#5
;;;3078     if (tmp == 1)               /* The flag to check is in CR register */
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L27.22|
;;;3079     {
;;;3080       statusreg = RCC->CR;
000010  4c0a              LDR      r4,|L27.60|
000012  6823              LDR      r3,[r4,#0]
000014  e008              B        |L27.40|
                  |L27.22|
;;;3081     }
;;;3082     else if (tmp == 2)          /* The flag to check is in BDCR register */
000016  2a02              CMP      r2,#2
000018  d103              BNE      |L27.34|
;;;3083     {
;;;3084       statusreg = RCC->BDCR;
00001a  4c08              LDR      r4,|L27.60|
00001c  3470              ADDS     r4,r4,#0x70
00001e  6823              LDR      r3,[r4,#0]
000020  e002              B        |L27.40|
                  |L27.34|
;;;3085     }
;;;3086     else                       /* The flag to check is in CSR register */
;;;3087     {
;;;3088       statusreg = RCC->CSR;
000022  4c06              LDR      r4,|L27.60|
000024  3474              ADDS     r4,r4,#0x74
000026  6823              LDR      r3,[r4,#0]
                  |L27.40|
;;;3089     }
;;;3090   
;;;3091     /* Get the flag position */
;;;3092     tmp = RCC_FLAG & FLAG_MASK;
000028  f001021f          AND      r2,r1,#0x1f
;;;3093     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
00002c  2401              MOVS     r4,#1
00002e  4094              LSLS     r4,r4,r2
000030  401c              ANDS     r4,r4,r3
000032  b10c              CBZ      r4,|L27.56|
;;;3094     {
;;;3095       bitstatus = SET;
000034  2001              MOVS     r0,#1
000036  e000              B        |L27.58|
                  |L27.56|
;;;3096     }
;;;3097     else
;;;3098     {
;;;3099       bitstatus = RESET;
000038  2000              MOVS     r0,#0
                  |L27.58|
;;;3100     }
;;;3101     /* Return the flag status */
;;;3102     return bitstatus;
;;;3103   }
00003a  bd10              POP      {r4,pc}
;;;3104   
                          ENDP

                  |L27.60|
                          DCD      0x40023800

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;3131     */
;;;3132   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;3133   {
;;;3134     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;3135   
;;;3136     /* Check the parameters */
;;;3137     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;3138   
;;;3139     /* Check the status of the specified RCC interrupt */
;;;3140     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L28.20|
000006  6812              LDR      r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L28.16|
;;;3141     {
;;;3142       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L28.18|
                  |L28.16|
;;;3143     }
;;;3144     else
;;;3145     {
;;;3146       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L28.18|
;;;3147     }
;;;3148     /* Return the RCC_IT status */
;;;3149     return  bitstatus;
;;;3150   }
000012  4770              BX       lr
;;;3151   
                          ENDP

                  |L28.20|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;1177     */
;;;1178   uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L29.12|
;;;1179   {
;;;1180     return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;1181   }
000008  4770              BX       lr
;;;1182   
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;1202     */
;;;1203   void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4601              MOV      r1,r0
;;;1204   {
;;;1205     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1206     
;;;1207     /* Check the parameters */
;;;1208     assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;1209   
;;;1210     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L30.20|
000006  6810              LDR      r0,[r2,#0]
;;;1211   
;;;1212     /* Clear HPRE[3:0] bits */
;;;1213     tmpreg &= ~RCC_CFGR_HPRE;
000008  f02000f0          BIC      r0,r0,#0xf0
;;;1214   
;;;1215     /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;1216     tmpreg |= RCC_SYSCLK;
00000c  4308              ORRS     r0,r0,r1
;;;1217   
;;;1218     /* Store the new value */
;;;1219     RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1220   }
000010  4770              BX       lr
;;;1221   
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;283      */
;;;284    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  2100              MOVS     r1,#0
;;;285    {
;;;286      /* Check the parameters */
;;;287      assert_param(IS_RCC_HSE(RCC_HSE));
;;;288    
;;;289      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;290      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  4a02              LDR      r2,|L31.12|
000004  7011              STRB     r1,[r2,#0]
;;;291    
;;;292      /* Set the new HSE configuration -------------------------------------------*/
;;;293      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  4611              MOV      r1,r2
000008  7008              STRB     r0,[r1,#0]
;;;294    }
00000a  4770              BX       lr
;;;295    
                          ENDP

                  |L31.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;374      */
;;;375    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L32.8|
;;;376    {
;;;377      /* Check the parameters */
;;;378      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;379    
;;;380      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;381    }
000004  4770              BX       lr
;;;382    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1544     */
;;;1545   void RCC_I2SCLKConfig(uint32_t RCC_I2SAPBx, uint32_t RCC_I2SCLKSource)
000000  b950              CBNZ     r0,|L33.24|
;;;1546   {
;;;1547     /* Check the parameters */
;;;1548     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1549     assert_param(IS_RCC_I2S_APBx(RCC_I2SAPBx));
;;;1550     
;;;1551     if(RCC_I2SAPBx == RCC_I2SBus_APB1)
;;;1552     {
;;;1553       /* Clear APB1 I2Sx clock source selection bits */
;;;1554       RCC->DCKCFGR &= ~RCC_DCKCFGR_I2S1SRC;
000002  4a0b              LDR      r2,|L33.48|
000004  6812              LDR      r2,[r2,#0]
000006  f02262c0          BIC      r2,r2,#0x6000000
00000a  4b09              LDR      r3,|L33.48|
00000c  601a              STR      r2,[r3,#0]
;;;1555       /* Set new APB1 I2Sx clock source*/
;;;1556       RCC->DCKCFGR |= RCC_I2SCLKSource;
00000e  461a              MOV      r2,r3
000010  6812              LDR      r2,[r2,#0]
000012  430a              ORRS     r2,r2,r1
000014  601a              STR      r2,[r3,#0]
000016  e00a              B        |L33.46|
                  |L33.24|
;;;1557     }
;;;1558     else
;;;1559     {
;;;1560       /* Clear APB2 I2Sx clock source selection  bits */
;;;1561       RCC->DCKCFGR &= ~RCC_DCKCFGR_I2S2SRC;
000018  4a05              LDR      r2,|L33.48|
00001a  6812              LDR      r2,[r2,#0]
00001c  f02252c0          BIC      r2,r2,#0x18000000
000020  4b03              LDR      r3,|L33.48|
000022  601a              STR      r2,[r3,#0]
;;;1562       /* Set new APB2 I2Sx clock source */
;;;1563       RCC->DCKCFGR |= (RCC_I2SCLKSource << 2);
000024  461a              MOV      r2,r3
000026  6812              LDR      r2,[r2,#0]
000028  ea420281          ORR      r2,r2,r1,LSL #2
00002c  601a              STR      r2,[r3,#0]
                  |L33.46|
;;;1564     }
;;;1565   }
00002e  4770              BX       lr
;;;1566   #if defined(STM32F446xx)
                          ENDP

                  |L33.48|
                          DCD      0x4002388c

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;3029     */
;;;3030   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L34.14|
;;;3031   {
;;;3032     /* Check the parameters */
;;;3033     assert_param(IS_RCC_IT(RCC_IT));
;;;3034     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3035     if (NewState != DISABLE)
;;;3036     {
;;;3037       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;3038       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000002  4a06              LDR      r2,|L34.28|
000004  7812              LDRB     r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L34.28|
00000a  701a              STRB     r2,[r3,#0]
00000c  e004              B        |L34.24|
                  |L34.14|
;;;3039     }
;;;3040     else
;;;3041     {
;;;3042       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;3043       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00000e  4a03              LDR      r2,|L34.28|
000010  7812              LDRB     r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L34.28|
000016  701a              STRB     r2,[r3,#0]
                  |L34.24|
;;;3044     }
;;;3045   }
000018  4770              BX       lr
;;;3046   
                          ENDP

00001a  0000              DCW      0x0000
                  |L34.28|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;399      */
;;;400    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  2100              MOVS     r1,#0
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_RCC_LSE(RCC_LSE));
;;;404    
;;;405      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;406      /* Reset LSEON bit */
;;;407      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  4a09              LDR      r2,|L35.40|
000004  7011              STRB     r1,[r2,#0]
;;;408    
;;;409      /* Reset LSEBYP bit */
;;;410      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  7011              STRB     r1,[r2,#0]
;;;411    
;;;412      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;413      switch (RCC_LSE)
000008  2801              CMP      r0,#1
00000a  d002              BEQ      |L35.18|
00000c  2804              CMP      r0,#4
00000e  d108              BNE      |L35.34|
000010  e003              B        |L35.26|
                  |L35.18|
;;;414      {
;;;415        case RCC_LSE_ON:
;;;416          /* Set LSEON bit */
;;;417          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
000012  2101              MOVS     r1,#1
000014  4a04              LDR      r2,|L35.40|
000016  7011              STRB     r1,[r2,#0]
;;;418          break;
000018  e004              B        |L35.36|
                  |L35.26|
;;;419        case RCC_LSE_Bypass:
;;;420          /* Set LSEBYP and LSEON bits */
;;;421          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
00001a  2105              MOVS     r1,#5
00001c  4a02              LDR      r2,|L35.40|
00001e  7011              STRB     r1,[r2,#0]
;;;422          break;
000020  e000              B        |L35.36|
                  |L35.34|
;;;423        default:
;;;424          break;
000022  bf00              NOP      
                  |L35.36|
000024  bf00              NOP                            ;418
;;;425      }
;;;426    }
000026  4770              BX       lr
;;;427    
                          ENDP

                  |L35.40|
                          DCD      0x40023870

                          AREA ||i.RCC_LSEModeConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEModeConfig PROC
;;;2717     */
;;;2718   void RCC_LSEModeConfig(uint8_t RCC_Mode)
000000  2801              CMP      r0,#1
;;;2719   {
;;;2720     /* Check the parameters */
;;;2721     assert_param(IS_RCC_LSE_MODE(RCC_Mode));
;;;2722     
;;;2723     if(RCC_Mode == RCC_LSE_HIGHDRIVE_MODE)
000002  d106              BNE      |L36.18|
;;;2724     {
;;;2725       SET_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
000004  4906              LDR      r1,|L36.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0410108          ORR      r1,r1,#8
00000c  4a04              LDR      r2,|L36.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L36.30|
                  |L36.18|
;;;2726     }
;;;2727     else
;;;2728     {
;;;2729       CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
000012  4903              LDR      r1,|L36.32|
000014  6809              LDR      r1,[r1,#0]
000016  f0210108          BIC      r1,r1,#8
00001a  4a01              LDR      r2,|L36.32|
00001c  6011              STR      r1,[r2,#0]
                  |L36.30|
;;;2730     }
;;;2731   }
00001e  4770              BX       lr
;;;2732   
                          ENDP

                  |L36.32|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;439      */
;;;440    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L37.8|
;;;441    {
;;;442      /* Check the parameters */
;;;443      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;444    
;;;445      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;446    }
000004  4770              BX       lr
;;;447    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_LTDCCLKDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_LTDCCLKDivConfig PROC
;;;1933     */
;;;1934   void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
000000  4601              MOV      r1,r0
;;;1935   {
;;;1936     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1937     
;;;1938     /* Check the parameters */
;;;1939     assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
;;;1940     
;;;1941     tmpreg = RCC->DCKCFGR;
000004  4a03              LDR      r2,|L38.20|
000006  6810              LDR      r0,[r2,#0]
;;;1942   
;;;1943     /* Clear PLLSAIDIVR[2:0] bits */
;;;1944     tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
000008  f4203040          BIC      r0,r0,#0x30000
;;;1945   
;;;1946     /* Set PLLSAIDIVR values */
;;;1947     tmpreg |= RCC_PLLSAIDivR;
00000c  4308              ORRS     r0,r0,r1
;;;1948   
;;;1949     /* Store the new value */
;;;1950     RCC->DCKCFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1951   }
000010  4770              BX       lr
;;;1952   
                          ENDP

000012  0000              DCW      0x0000
                  |L38.20|
                          DCD      0x4002388c

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;903      */
;;;904    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4602              MOV      r2,r0
;;;905    {
;;;906      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;907      
;;;908      /* Check the parameters */
;;;909      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;910      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;911    
;;;912      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L39.24|
000006  6818              LDR      r0,[r3,#0]
;;;913    
;;;914      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;915      tmpreg &= CFGR_MCO1_RESET_MASK;
000008  f02060ec          BIC      r0,r0,#0x7600000
;;;916    
;;;917      /* Select MCO1 clock source and prescaler */
;;;918      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;919      
;;;920      /* Store the new value */
;;;921      RCC->CFGR = tmpreg;
000012  4b01              LDR      r3,|L39.24|
000014  6018              STR      r0,[r3,#0]
;;;922    
;;;923    #if defined(STM32F410xx)
;;;924      RCC_MCO1Cmd(ENABLE);
;;;925    #endif /* STM32F410xx */   
;;;926    }
000016  4770              BX       lr
;;;927    
                          ENDP

                  |L39.24|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;948      */
;;;949    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4602              MOV      r2,r0
;;;950    {
;;;951      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;952      
;;;953      /* Check the parameters */
;;;954      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;955      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;956      
;;;957      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L40.24|
000006  6818              LDR      r0,[r3,#0]
;;;958      
;;;959      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;960      tmpreg &= CFGR_MCO2_RESET_MASK;
000008  f0204078          BIC      r0,r0,#0xf8000000
;;;961    
;;;962      /* Select MCO2 clock source and prescaler */
;;;963      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;964      
;;;965      /* Store the new value */
;;;966      RCC->CFGR = tmpreg;
000012  4b01              LDR      r3,|L40.24|
000014  6018              STR      r0,[r3,#0]
;;;967    
;;;968    #if defined(STM32F410xx)
;;;969      RCC_MCO2Cmd(ENABLE);
;;;970    #endif /* STM32F410xx */   
;;;971    }
000016  4770              BX       lr
;;;972    
                          ENDP

                  |L40.24|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;1233     */
;;;1234   void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;1235   {
;;;1236     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1237   
;;;1238     /* Check the parameters */
;;;1239     assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;1240   
;;;1241     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L41.20|
000006  6810              LDR      r0,[r2,#0]
;;;1242   
;;;1243     /* Clear PPRE1[2:0] bits */
;;;1244     tmpreg &= ~RCC_CFGR_PPRE1;
000008  f42050e0          BIC      r0,r0,#0x1c00
;;;1245   
;;;1246     /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;1247     tmpreg |= RCC_HCLK;
00000c  4308              ORRS     r0,r0,r1
;;;1248   
;;;1249     /* Store the new value */
;;;1250     RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1251   }
000010  4770              BX       lr
;;;1252   
                          ENDP

000012  0000              DCW      0x0000
                  |L41.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;1264     */
;;;1265   void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;1266   {
;;;1267     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1268   
;;;1269     /* Check the parameters */
;;;1270     assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;1271   
;;;1272     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L42.20|
000006  6810              LDR      r0,[r2,#0]
;;;1273   
;;;1274     /* Clear PPRE2[2:0] bits */
;;;1275     tmpreg &= ~RCC_CFGR_PPRE2;
000008  f4204060          BIC      r0,r0,#0xe000
;;;1276   
;;;1277     /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;1278     tmpreg |= RCC_HCLK << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;1279   
;;;1280     /* Store the new value */
;;;1281     RCC->CFGR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;1282   }
000012  4770              BX       lr
;;;1283   
                          ENDP

                  |L42.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;562      */
;;;563    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L43.8|
;;;564    {
;;;565      /* Check the parameters */
;;;566      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;567      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;568    }
000004  4770              BX       lr
;;;569    
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;487      */
;;;488    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ, uint32_t PLLR)
000000  b5f0              PUSH     {r4-r7,lr}
;;;489    {
000002  e9dd4505          LDRD     r4,r5,[sp,#0x14]
;;;490      /* Check the parameters */
;;;491      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;492      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;493      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;494      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;495      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;496      assert_param(IS_RCC_PLLR_VALUE(PLLR));
;;;497      
;;;498      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000006  ea411682          ORR      r6,r1,r2,LSL #6
00000a  2701              MOVS     r7,#1
00000c  ebc70753          RSB      r7,r7,r3,LSR #1
000010  ea464607          ORR      r6,r6,r7,LSL #16
000014  4306              ORRS     r6,r6,r0
000016  ea466604          ORR      r6,r6,r4,LSL #24
00001a  ea467605          ORR      r6,r6,r5,LSL #28
00001e  4f01              LDR      r7,|L44.36|
000020  603e              STR      r6,[r7,#0]
;;;499                     (PLLQ << 24) | (PLLR << 28);
;;;500    }
000022  bdf0              POP      {r4-r7,pc}
;;;501    #endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
                          ENDP

                  |L44.36|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;731      */
;;;732    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L45.8|
;;;733    {
;;;734      /* Check the parameters */
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;736      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;737    }
000004  4770              BX       lr
;;;738    
                          ENDP

000006  0000              DCW      0x0000
                  |L45.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;712      */
;;;713    void RCC_PLLI2SConfig(uint32_t PLLI2SM, uint32_t PLLI2SN, uint32_t PLLI2SP, uint32_t PLLI2SQ, uint32_t PLLI2SR)
000000  b570              PUSH     {r4-r6,lr}
;;;714    {
000002  9c04              LDR      r4,[sp,#0x10]
;;;715      /* Check the parameters */
;;;716      assert_param(IS_RCC_PLLI2SM_VALUE(PLLI2SM));
;;;717      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;718      assert_param(IS_RCC_PLLI2SP_VALUE(PLLI2SP));
;;;719      assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SQ));
;;;720      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;721    
;;;722      RCC->PLLI2SCFGR =  PLLI2SM | (PLLI2SN << 6) | (((PLLI2SP >> 1) -1) << 16) | (PLLI2SQ << 24) | (PLLI2SR << 28);
000004  ea401581          ORR      r5,r0,r1,LSL #6
000008  2601              MOVS     r6,#1
00000a  ebc60652          RSB      r6,r6,r2,LSR #1
00000e  ea454506          ORR      r5,r5,r6,LSL #16
000012  ea456503          ORR      r5,r5,r3,LSL #24
000016  ea457504          ORR      r5,r5,r4,LSL #28
00001a  4e01              LDR      r6,|L46.32|
00001c  6035              STR      r5,[r6,#0]
;;;723    }
00001e  bd70              POP      {r4-r6,pc}
;;;724    #endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
                          ENDP

                  |L46.32|
                          DCD      0x40023884

                          AREA ||i.RCC_PLLSAICmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAICmd PROC
;;;860      */
;;;861    void RCC_PLLSAICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L47.8|
;;;862    {
;;;863      /* Check the parameters */
;;;864      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;865      *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
000002  6708              STR      r0,[r1,#0x70]
;;;866    }
000004  4770              BX       lr
;;;867    
                          ENDP

000006  0000              DCW      0x0000
                  |L47.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLSAIConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAIConfig PROC
;;;805      */
;;;806    void RCC_PLLSAIConfig(uint32_t PLLSAIM, uint32_t PLLSAIN, uint32_t PLLSAIP, uint32_t PLLSAIQ)
000000  b530              PUSH     {r4,r5,lr}
;;;807    {
;;;808      /* Check the parameters */
;;;809      assert_param(IS_RCC_PLLSAIM_VALUE(PLLSAIM));
;;;810      assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
;;;811      assert_param(IS_RCC_PLLSAIP_VALUE(PLLSAIP));
;;;812      assert_param(IS_RCC_PLLSAIQ_VALUE(PLLSAIQ));
;;;813    
;;;814      RCC->PLLSAICFGR = PLLSAIM | (PLLSAIN << 6) | (((PLLSAIP >> 1) -1) << 16)  | (PLLSAIQ << 24);
000002  ea401481          ORR      r4,r0,r1,LSL #6
000006  2501              MOVS     r5,#1
000008  ebc50552          RSB      r5,r5,r2,LSR #1
00000c  ea444405          ORR      r4,r4,r5,LSL #16
000010  ea446403          ORR      r4,r4,r3,LSL #24
000014  4d01              LDR      r5,|L48.28|
000016  602c              STR      r4,[r5,#0]
;;;815    }
000018  bd30              POP      {r4,r5,pc}
;;;816    #endif /* STM32F446xx */
                          ENDP

00001a  0000              DCW      0x0000
                  |L48.28|
                          DCD      0x40023888

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1501     */
;;;1502   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L49.8|
;;;1503   {
;;;1504     /* Check the parameters */
;;;1505     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1506   
;;;1507     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1508   }
000004  4770              BX       lr
;;;1509   
                          ENDP

000006  0000              DCW      0x0000
                  |L49.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1469     */
;;;1470   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  2100              MOVS     r1,#0
;;;1471   {
;;;1472     uint32_t tmpreg = 0;
;;;1473   
;;;1474     /* Check the parameters */
;;;1475     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1476   
;;;1477     if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000002  f4007240          AND      r2,r0,#0x300
000006  f5b27f40          CMP      r2,#0x300
00000a  d108              BNE      |L50.30|
;;;1478     { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;1479       tmpreg = RCC->CFGR;
00000c  4a09              LDR      r2,|L50.52|
00000e  6811              LDR      r1,[r2,#0]
;;;1480   
;;;1481       /* Clear RTCPRE[4:0] bits */
;;;1482       tmpreg &= ~RCC_CFGR_RTCPRE;
000010  f42111f8          BIC      r1,r1,#0x1f0000
;;;1483   
;;;1484       /* Configure HSE division factor for RTC clock */
;;;1485       tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
000014  4a08              LDR      r2,|L50.56|
000016  4002              ANDS     r2,r2,r0
000018  4311              ORRS     r1,r1,r2
;;;1486   
;;;1487       /* Store the new value */
;;;1488       RCC->CFGR = tmpreg;
00001a  4a06              LDR      r2,|L50.52|
00001c  6011              STR      r1,[r2,#0]
                  |L50.30|
;;;1489     }
;;;1490       
;;;1491     /* Select the RTC clock source */
;;;1492     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
00001e  4a05              LDR      r2,|L50.52|
000020  3268              ADDS     r2,r2,#0x68
000022  6812              LDR      r2,[r2,#0]
000024  f3c0030b          UBFX     r3,r0,#0,#12
000028  431a              ORRS     r2,r2,r3
00002a  4b02              LDR      r3,|L50.52|
00002c  3368              ADDS     r3,r3,#0x68
00002e  601a              STR      r2,[r3,#0]
;;;1493   }
000030  4770              BX       lr
;;;1494   
                          ENDP

000032  0000              DCW      0x0000
                  |L50.52|
                          DCD      0x40023808
                  |L50.56|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SAICLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAICLKConfig PROC
;;;1583     */
;;;1584   void RCC_SAICLKConfig(uint32_t RCC_SAIInstance, uint32_t RCC_SAICLKSource)
000000  b950              CBNZ     r0,|L51.24|
;;;1585   {
;;;1586     /* Check the parameters */
;;;1587     assert_param(IS_RCC_SAICLK_SOURCE(RCC_SAICLKSource));
;;;1588     assert_param(IS_RCC_SAI_INSTANCE(RCC_SAIInstance));
;;;1589     
;;;1590     if(RCC_SAIInstance == RCC_SAIInstance_SAI1)
;;;1591     {
;;;1592       /* Clear SAI1 clock source selection bits */
;;;1593       RCC->DCKCFGR &= ~RCC_DCKCFGR_SAI1SRC;
000002  4a0b              LDR      r2,|L51.48|
000004  6812              LDR      r2,[r2,#0]
000006  f4221240          BIC      r2,r2,#0x300000
00000a  4b09              LDR      r3,|L51.48|
00000c  601a              STR      r2,[r3,#0]
;;;1594       /* Set new SAI1 clock source */
;;;1595       RCC->DCKCFGR |= RCC_SAICLKSource;
00000e  461a              MOV      r2,r3
000010  6812              LDR      r2,[r2,#0]
000012  430a              ORRS     r2,r2,r1
000014  601a              STR      r2,[r3,#0]
000016  e00a              B        |L51.46|
                  |L51.24|
;;;1596     }
;;;1597     else
;;;1598     {
;;;1599       /* Clear SAI2 clock source selection bits */
;;;1600       RCC->DCKCFGR &= ~RCC_DCKCFGR_SAI2SRC;
000018  4a05              LDR      r2,|L51.48|
00001a  6812              LDR      r2,[r2,#0]
00001c  f4220240          BIC      r2,r2,#0xc00000
000020  4b03              LDR      r3,|L51.48|
000022  601a              STR      r2,[r3,#0]
;;;1601       /* Set new SAI2 clock source */
;;;1602       RCC->DCKCFGR |= (RCC_SAICLKSource << 2);
000024  461a              MOV      r2,r3
000026  6812              LDR      r2,[r2,#0]
000028  ea420281          ORR      r2,r2,r1,LSL #2
00002c  601a              STR      r2,[r3,#0]
                  |L51.46|
;;;1603     }
;;;1604   }
00002e  4770              BX       lr
;;;1605   #endif /* STM32F446xx */
                          ENDP

                  |L51.48|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLI2SClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLI2SClkDivConfig PROC
;;;1802     */
;;;1803   void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
000000  4601              MOV      r1,r0
;;;1804   {
;;;1805     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1806     
;;;1807     /* Check the parameters */
;;;1808     assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
;;;1809     
;;;1810     tmpreg = RCC->DCKCFGR;
000004  4a04              LDR      r2,|L52.24|
000006  6810              LDR      r0,[r2,#0]
;;;1811   
;;;1812     /* Clear PLLI2SDIVQ[4:0] bits */
;;;1813     tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
000008  f020001f          BIC      r0,r0,#0x1f
;;;1814   
;;;1815     /* Set PLLI2SDIVQ values */
;;;1816     tmpreg |= (RCC_PLLI2SDivQ - 1);
00000c  1e4a              SUBS     r2,r1,#1
00000e  4310              ORRS     r0,r0,r2
;;;1817   
;;;1818     /* Store the new value */
;;;1819     RCC->DCKCFGR = tmpreg;
000010  4a01              LDR      r2,|L52.24|
000012  6010              STR      r0,[r2,#0]
;;;1820   }
000014  4770              BX       lr
;;;1821   
                          ENDP

000016  0000              DCW      0x0000
                  |L52.24|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLSAIClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLSAIClkDivConfig PROC
;;;1834     */
;;;1835   void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
000000  4601              MOV      r1,r0
;;;1836   {
;;;1837     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1838     
;;;1839     /* Check the parameters */
;;;1840     assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
;;;1841     
;;;1842     tmpreg = RCC->DCKCFGR;
000004  4a04              LDR      r2,|L53.24|
000006  6810              LDR      r0,[r2,#0]
;;;1843   
;;;1844     /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
;;;1845     tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
000008  f42050f8          BIC      r0,r0,#0x1f00
;;;1846   
;;;1847     /* Set PLLSAIDIVQ values */
;;;1848     tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
00000c  1e4a              SUBS     r2,r1,#1
00000e  ea402002          ORR      r0,r0,r2,LSL #8
;;;1849   
;;;1850     /* Store the new value */
;;;1851     RCC->DCKCFGR = tmpreg;
000012  4a01              LDR      r2,|L53.24|
000014  6010              STR      r0,[r2,#0]
;;;1852   }
000016  4770              BX       lr
;;;1853   
                          ENDP

                  |L53.24|
                          DCD      0x4002388c

                          AREA ||i.RCC_SDIOClockSourceConfig||, CODE, READONLY, ALIGN=2

                  RCC_SDIOClockSourceConfig PROC
;;;2837     */
;;;2838   void RCC_SDIOClockSourceConfig(uint8_t RCC_ClockSource)
000000  2801              CMP      r0,#1
;;;2839   {
;;;2840     /* Check the parameters */
;;;2841     assert_param(IS_RCC_SDIO_CLOCKSOURCE(RCC_ClockSource));
;;;2842   #if defined(STM32F469_479xx)   
;;;2843     if(RCC_ClockSource == RCC_SDIOCLKSource_SYSCLK)
;;;2844     {
;;;2845       SET_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SDIOSEL);
;;;2846     }
;;;2847     else
;;;2848     {
;;;2849       CLEAR_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SDIOSEL);
;;;2850     }
;;;2851   #elif defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
;;;2852     if(RCC_ClockSource == RCC_SDIOCLKSource_SYSCLK)
000002  d106              BNE      |L54.18|
;;;2853     {
;;;2854       SET_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL);
000004  4906              LDR      r1,|L54.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0415180          ORR      r1,r1,#0x10000000
00000c  4a04              LDR      r2,|L54.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L54.30|
                  |L54.18|
;;;2855     }
;;;2856     else
;;;2857     {
;;;2858       CLEAR_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL);
000012  4903              LDR      r1,|L54.32|
000014  6809              LDR      r1,[r1,#0]
000016  f0215180          BIC      r1,r1,#0x10000000
00001a  4a01              LDR      r2,|L54.32|
00001c  6011              STR      r1,[r2,#0]
                  |L54.30|
;;;2859     }
;;;2860   #else
;;;2861   #endif /* STM32F469_479xx */ 
;;;2862   }
00001e  4770              BX       lr
;;;2863   #endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
                          ENDP

                  |L54.32|
                          DCD      0x40023894

                          AREA ||i.RCC_SPDIFRXClockSourceConfig||, CODE, READONLY, ALIGN=2

                  RCC_SPDIFRXClockSourceConfig PROC
;;;2906     */
;;;2907   void RCC_SPDIFRXClockSourceConfig(uint8_t RCC_ClockSource)
000000  2801              CMP      r0,#1
;;;2908   {
;;;2909     /* Check the parameters */
;;;2910     assert_param(IS_RCC_SPDIFRX_CLOCKSOURCE(RCC_ClockSource));
;;;2911     
;;;2912     if(RCC_ClockSource == RCC_SPDIFRXCLKSource_PLLI2SP)
000002  d106              BNE      |L55.18|
;;;2913     {
;;;2914       SET_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SPDIFRXSEL);
000004  4906              LDR      r1,|L55.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0415100          ORR      r1,r1,#0x20000000
00000c  4a04              LDR      r2,|L55.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L55.30|
                  |L55.18|
;;;2915     }
;;;2916     else
;;;2917     {
;;;2918       CLEAR_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SPDIFRXSEL);
000012  4903              LDR      r1,|L55.32|
000014  6809              LDR      r1,[r1,#0]
000016  f0215100          BIC      r1,r1,#0x20000000
00001a  4a01              LDR      r2,|L55.32|
00001c  6011              STR      r1,[r2,#0]
                  |L55.30|
;;;2919     }
;;;2920   }
00001e  4770              BX       lr
;;;2921   
                          ENDP

                  |L55.32|
                          DCD      0x40023894

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;1148     */
;;;1149   void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4601              MOV      r1,r0
;;;1150   {
;;;1151     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1152   
;;;1153     /* Check the parameters */
;;;1154     assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;1155   
;;;1156     tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L56.20|
000006  6810              LDR      r0,[r2,#0]
;;;1157   
;;;1158     /* Clear SW[1:0] bits */
;;;1159     tmpreg &= ~RCC_CFGR_SW;
000008  f0200003          BIC      r0,r0,#3
;;;1160   
;;;1161     /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;1162     tmpreg |= RCC_SYSCLKSource;
00000c  4308              ORRS     r0,r0,r1
;;;1163   
;;;1164     /* Store the new value */
;;;1165     RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;1166   }
000010  4770              BX       lr
;;;1167   
                          ENDP

000012  0000              DCW      0x0000
                  |L56.20|
                          DCD      0x40023808

                          AREA ||i.RCC_TIMCLKPresConfig||, CODE, READONLY, ALIGN=2

                  RCC_TIMCLKPresConfig PROC
;;;2061     */
;;;2062   void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
000000  4901              LDR      r1,|L57.8|
;;;2063   {
;;;2064     /* Check the parameters */
;;;2065     assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
;;;2066   
;;;2067     *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
000002  6008              STR      r0,[r1,#0]
;;;2068   }
000004  4770              BX       lr
;;;2069   
                          ENDP

000006  0000              DCW      0x0000
                  |L57.8|
                          DCD      0x424711e0

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;307      */
;;;308    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;309    {
;;;310      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;311      ErrorStatus status = ERROR;
000006  2400              MOVS     r4,#0
;;;312      FlagStatus hsestatus = RESET;
000008  2500              MOVS     r5,#0
;;;313      /* Wait till HSE is ready and if Time out is reached exit */
;;;314      do
00000a  bf00              NOP      
                  |L58.12|
;;;315      {
;;;316        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000c  2031              MOVS     r0,#0x31
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  4605              MOV      r5,r0
;;;317        startupcounter++;
000014  9800              LDR      r0,[sp,#0]
000016  1c40              ADDS     r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;318      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
00001a  9800              LDR      r0,[sp,#0]
00001c  f5b04fa0          CMP      r0,#0x5000
000020  d001              BEQ      |L58.38|
000022  2d00              CMP      r5,#0
000024  d0f2              BEQ      |L58.12|
                  |L58.38|
;;;319    
;;;320      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000026  2031              MOVS     r0,#0x31
000028  f7fffffe          BL       RCC_GetFlagStatus
00002c  b108              CBZ      r0,|L58.50|
;;;321      {
;;;322        status = SUCCESS;
00002e  2401              MOVS     r4,#1
000030  e000              B        |L58.52|
                  |L58.50|
;;;323      }
;;;324      else
;;;325      {
;;;326        status = ERROR;
000032  2400              MOVS     r4,#0
                  |L58.52|
;;;327      }
;;;328      return (status);
000034  4620              MOV      r0,r4
;;;329    }
000036  bd38              POP      {r3-r5,pc}
;;;330    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 138 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 153
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____RRX|
#line 328
|__asm___15_stm32f4xx_rcc_c_49e27980____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
